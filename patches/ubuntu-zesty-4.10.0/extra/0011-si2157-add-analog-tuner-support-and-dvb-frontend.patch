From 9398e0de8f444e35e3059f9e114875b2dcf1f9d3 Mon Sep 17 00:00:00 2001
From: Brad Love <hidden@email.co>
Date: Thu, 5 Oct 2017 12:31:04 -0500
Subject: [PATCH 11/23] si2157: add analog tuner support and dvb frontend

---
 drivers/media/pci/saa7164/saa7164-dvb.c |   6 +-
 drivers/media/tuners/si2157.c           | 519 ++++++++++++++++++++++++++++----
 drivers/media/tuners/si2157.h           |  14 +
 drivers/media/tuners/si2157_priv.h      |   9 +
 drivers/media/tuners/tuner-types.c      |  15 +
 drivers/media/v4l2-core/tuner-core.c    |  22 ++
 include/media/tuner.h                   |   2 +
 7 files changed, 521 insertions(+), 66 deletions(-)

diff --git a/drivers/media/pci/saa7164/saa7164-dvb.c b/drivers/media/pci/saa7164/saa7164-dvb.c
index e76d3bafe2ce..a557e2920bd4 100644
--- a/drivers/media/pci/saa7164/saa7164-dvb.c
+++ b/drivers/media/pci/saa7164/saa7164-dvb.c
@@ -110,7 +110,7 @@ static struct si2157_config hauppauge_hvr2255_tuner_config = {
 	.if_port = 1,
 };
 
-static int si2157_attach(struct saa7164_port *port, struct i2c_adapter *adapter,
+static int si2157_attach_priv(struct saa7164_port *port, struct i2c_adapter *adapter,
 	struct dvb_frontend *fe, u8 addr8bit, struct si2157_config *cfg)
 {
 	struct i2c_board_info bi;
@@ -624,11 +624,11 @@ int saa7164_dvb_register(struct saa7164_port *port)
 		if (port->dvb.frontend != NULL) {
 
 			if (port->nr == 0) {
-				si2157_attach(port, &dev->i2c_bus[0].i2c_adap,
+				si2157_attach_priv(port, &dev->i2c_bus[0].i2c_adap,
 					      port->dvb.frontend, 0xc0,
 					      &hauppauge_hvr2255_tuner_config);
 			} else {
-				si2157_attach(port, &dev->i2c_bus[1].i2c_adap,
+				si2157_attach_priv(port, &dev->i2c_bus[1].i2c_adap,
 					      port->dvb.frontend, 0xc0,
 					      &hauppauge_hvr2255_tuner_config);
 			}
diff --git a/drivers/media/tuners/si2157.c b/drivers/media/tuners/si2157.c
index 6cd62ba82d57..3696ac1ab50f 100644
--- a/drivers/media/tuners/si2157.c
+++ b/drivers/media/tuners/si2157.c
@@ -1,5 +1,5 @@
 /*
- * Silicon Labs Si2146/2147/2148/2157/2158 silicon tuner driver
+ * Silicon Labs Si2141/2146/2147/2148/2157/2158 silicon tuner driver
  *
  * Copyright (C) 2014 Antti Palosaari <crope@iki.fi>
  *
@@ -18,6 +18,11 @@
 
 static const struct dvb_tuner_ops si2157_ops;
 
+static DEFINE_MUTEX(si2157_list_mutex);
+static LIST_HEAD(hybrid_tuner_instance_list);
+
+/*---------------------------------------------------------------------*/
+
 /* execute firmware command */
 static int si2157_cmd_execute(struct i2c_client *client, struct si2157_cmd *cmd)
 {
@@ -91,7 +96,7 @@ static int si2157_init(struct dvb_frontend *fe)
 	struct si2157_cmd cmd;
 	const struct firmware *fw;
 	const char *fw_name;
-	unsigned int uitmp, chip_id, xtal_trim;
+	unsigned int chip_id, xtal_trim;
 
 	dev_dbg(&client->dev, "\n");
 
@@ -238,6 +243,23 @@ static int si2157_init(struct dvb_frontend *fe)
 	dev_info(&client->dev, "firmware version: %c.%c.%d\n",
 			cmd.args[6], cmd.args[7], cmd.args[8]);
 
+	if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		/* set clock */
+		memcpy(cmd.args, "\xc0\x00\x0d", 3);
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+		/* setup PIN */
+		memcpy(cmd.args, "\x12\x80\x80\x85\x00\x81\x00", 7);
+		cmd.wlen = 7;
+		cmd.rlen = 7;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+	}
+
 	/* enable tuner status flags, for si2157_tune_wait() */
 	memcpy(cmd.args, "\x14\x00\x01\x05\x01\x00", 6);
 	cmd.wlen = 6;
@@ -279,7 +301,7 @@ static int si2157_sleep(struct dvb_frontend *fe)
 {
 	struct i2c_client *client = fe->tuner_priv;
 	struct si2157_dev *dev = i2c_get_clientdata(client);
-	int ret;
+	int ret = 0;
 	struct si2157_cmd cmd;
 
 	dev_dbg(&client->dev, "\n");
@@ -449,7 +471,7 @@ static int si2157_set_params(struct dvb_frontend *fe)
 	if (ret)
 		goto err;
 
-	/* set if frequency if needed */
+	/* set digital if frequency if needed */
 	if (if_frequency != dev->if_frequency) {
 		memcpy(cmd.args, "\x14\x00\x06\x07", 4);
 		cmd.args[4] = (if_frequency / 1000) & 0xff;
@@ -463,7 +485,7 @@ static int si2157_set_params(struct dvb_frontend *fe)
 		dev->if_frequency = if_frequency;
 	}
 
-	/* set frequency */
+	/* set digital frequency */
 	memcpy(cmd.args, "\x41\x00\x00\x00\x00\x00\x00\x00", 8);
 	cmd.args[4] = (c->frequency >>  0) & 0xff;
 	cmd.args[5] = (c->frequency >>  8) & 0xff;
@@ -477,24 +499,306 @@ static int si2157_set_params(struct dvb_frontend *fe)
 
 	si2157_tune_wait(client, 1); /* wait for tuning to complete, ignore any errors */
 
+	dev->bandwidth = bandwidth;
+	dev->frequency = c->frequency;
+
 	return 0;
 err:
+	dev->bandwidth = 0;
+	dev->frequency = 0;
+	dev->if_frequency = 0;
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
+static int si2157_set_analog_params(struct dvb_frontend *fe,
+				      struct analog_parameters *params)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = i2c_get_clientdata(client);
+	char *std; /* for debugging */
+	int ret;
+	struct si2157_cmd cmd;
+	u32 bandwidth = 0;
+	u32 if_frequency = 0;
+	u32 freq = 0;
+	u64 tmp_lval = 0;
+	u8 system = 0;
+	u8 color = 0;    /* 0=NTSC/PAL, 0x10=SECAM */
+	u8 invert_analog = 1; /* analog tuner spectrum; 0=normal, 1=inverted */
+
+	if (dev->chiptype != SI2157_CHIPTYPE_SI2157) {
+		printk(KERN_INFO "%s: Analog tuning not supported for chiptype=%u\n",
+				__func__, dev->chiptype);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (!dev->active) {
+		si2157_init(fe);
+	}
+	if (!dev->active) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	if (params->mode == V4L2_TUNER_RADIO) {
+	/*
+	 * std = "fm";
+	 * bandwidth = 1700000; //best we can do for FM on si2157 tuner, AGC will be a mess though
+	 * if_frequency = 1250000;  //HVR-225x(saa7164), HVR-12xx(cx23885)
+	 * if_frequency = 6600000;  //HVR-9xx(cx231xx)
+	 * if_frequency = 5500000;  //HVR-19xx(pvrusb2)
+	 */
+		dev_dbg(&client->dev, "si2157 does not currently support FM radio\n");
+		ret = -EINVAL;
+		goto err;
+	}
+	tmp_lval = params->frequency * 625LL;
+	do_div(tmp_lval, 10); /* convert to HZ */
+	freq = (u32)tmp_lval;
+
+	if(freq < 1000000) /* is freq in KHz */
+		freq = freq * 1000;
+	dev->frequency = freq;
+
+	if (params->std & (V4L2_STD_B|V4L2_STD_GH)) {
+		if(freq >= 470000000){
+			std = "palGH";
+			bandwidth = 8000000;
+			if_frequency = 6000000; /* matches tda18271C2, works w/cx23885 */
+			system = 1;
+			if(params->std & (V4L2_STD_SECAM_G|V4L2_STD_SECAM_H)){
+				std = "secamGH";
+				color=0x10;
+			}
+		} else {
+			std = "palB";
+			bandwidth = 7000000;
+			if_frequency = 6000000; /* matches tda18271C2, works w/cx23885 */;
+			system = 0;
+			if(params->std & V4L2_STD_SECAM_B){
+				std = "secamB";
+				color=0x10;
+			}
+		}
+	} else if (params->std & V4L2_STD_MN) {
+		std = "MN";
+		bandwidth = 6000000;
+		if_frequency = 5400000; /* matches tda18271C2, works w/cx23885 */
+		system = 2;
+	} else if (params->std & V4L2_STD_PAL_I) {
+		std = "palI";
+		bandwidth = 8000000;
+		if_frequency = 7250000; /* matches tda18271C2, does not work yet w/cx23885 */
+		system = 4;
+	} else if (params->std & V4L2_STD_DK) {
+		std = "palDK";
+		bandwidth = 8000000;
+		if_frequency = 6900000; /* matches tda18271C2, does not work yet w/cx23885 */
+		system = 5;
+		if (params->std & V4L2_STD_SECAM_DK){
+			std = "secamDK";
+			color=0x10;
+		}
+	} else if (params->std & V4L2_STD_SECAM_L) {
+		std = "secamL";
+		bandwidth = 8000000;
+		if_frequency = 6750000; /* not tested yet w/cx23885 */
+		system = 6;  color=0x10;
+	} else if (params->std & V4L2_STD_SECAM_LC) {
+		std = "secamL'";
+		bandwidth = 7000000;
+		if_frequency = 1250000; /* not tested yet w/cx23885 */
+		system = 7;  color=0x10;
+	} else {
+		std = "unknown";
+	}
+	/* calc channel center freq */
+	freq = freq - 1250000 + (bandwidth/2);
+
+	dev_dbg(&client->dev,
+			"mode=%d system=%u std='%s' params->frequency=%u center freq=%u if=%u bandwidth=%u\n",
+			params->mode, system, std, params->frequency,
+			freq, if_frequency, bandwidth);
+
+	/* set analog IF port */
+	memcpy(cmd.args, "\x14\x00\x03\x06\x08\x02", 6);
+	/* in using dev->if_port, we assume analog and digital IF's are always on different ports */
+	cmd.args[4] = (dev->if_port==1)?8:10; /* assumes if_port definition is 0 or 1 for digital out */
+	cmd.args[5] = (dev->if_port==1)?2:1;  /* Analog AGC assumed to be external */
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* set analog IF output config */
+	memcpy(cmd.args, "\x14\x00\x0d\x06\x94\x64", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	dev->if_frequency = if_frequency | 1; /* make this distinct from a digital IF */
+
+	/* calc and set tuner analog if center frequency */
+	if_frequency = if_frequency + 1250000 - (bandwidth/2);
+	dev_dbg(&client->dev, "IF Ctr freq=%d\n", if_frequency);
+
+	memcpy(cmd.args, "\x14\x00\x0C\x06", 4);
+	cmd.args[4] = (if_frequency / 1000) & 0xff;
+	cmd.args[5] = ((if_frequency / 1000) >> 8) & 0xff;
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* set analog AGC config */
+	memcpy(cmd.args, "\x14\x00\x07\x06\x32\xc8", 6);
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* set analog video mode */
+	memcpy(cmd.args, "\x14\x00\x04\x06\x00\x00", 6);
+	cmd.args[4] = system | color;
+#if 1 /* BUGBUG - can use dev->inversion if we assume it applies to both digital and analog */
+	if (invert_analog)
+		cmd.args[5] |= 0x02;
+#else
+	if (dev->inversion)
+		cmd.args[5] |= 0x02;
+#endif
+	cmd.wlen = 6;
+	cmd.rlen = 1;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	/* set analog frequency */
+	memcpy(cmd.args, "\x41\x01\x00\x00\x00\x00\x00\x00", 8);
+	cmd.args[4] = (freq >>  0) & 0xff;
+	cmd.args[5] = (freq >>  8) & 0xff;
+	cmd.args[6] = (freq >> 16) & 0xff;
+	cmd.args[7] = (freq >> 24) & 0xff;
+	cmd.wlen = 8;
+	cmd.rlen = 1;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
+	si2157_tune_wait(client, 0); /* wait for tuning to complete, ignore any errors */
+
+#if 1//testing
+	/* get tuner status, RSSI values */
+	memcpy(cmd.args, "\x42\x01", 2);
+	cmd.wlen = 2;
+	cmd.rlen = 12;
+	ret = si2157_cmd_execute(client, &cmd);
+
+	printk(KERN_INFO "%s: tuner status: ret=%d rssi=%d mode=%x freq=%d\n",
+		__func__, ret, cmd.args[3], cmd.args[8],
+		cmd.args[7]<<24 | cmd.args[6]<<16 | cmd.args[5]<<8 | cmd.args[4]);
+#endif
+
+	dev->bandwidth = bandwidth;
+
+	return 0;
+err:
+	dev->bandwidth = 0;
+	dev->frequency = 0;
+	dev->if_frequency = 0;
+	dev_dbg(&client->dev, "failed=%d\n", ret);
+	return ret;
+}
+
+static int si2157_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = i2c_get_clientdata(client);
+
+	*frequency = dev->frequency;
+	printk(KERN_INFO "%s: freq=%u\n", __func__, dev->frequency);
+	return 0;
+}
+
+static int si2157_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = i2c_get_clientdata(client);
+
+	*bandwidth = dev->bandwidth;
+	printk(KERN_INFO "%s: bandwidth=%u\n", __func__, dev->bandwidth);
+	return 0;
+}
+
 static int si2157_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
 {
 	struct i2c_client *client = fe->tuner_priv;
 	struct si2157_dev *dev = i2c_get_clientdata(client);
 
-	*frequency = dev->if_frequency;
+	*frequency = dev->if_frequency & ~1; /* strip analog IF indicator bit */
+	printk(KERN_INFO "%s: if_frequency=%u\n", __func__, *frequency);
+	return 0;
+}
+
+static void si2157_release(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = NULL;
+	printk(KERN_INFO "%s: client=%p\n", __func__, client);
+	if(client == NULL)
+		return;
+
+	dev = i2c_get_clientdata(client);
+	printk(KERN_INFO "%s: dev=%p\n", __func__, dev);
+	if(dev == NULL)
+		return;
+
+	mutex_lock(&si2157_list_mutex);
+	hybrid_tuner_release_state(dev);
+	mutex_unlock(&si2157_list_mutex);
+
+	i2c_set_clientdata(client, NULL);
+	fe->tuner_priv = NULL;
+}
+
+static int si2157_setup_configuration(struct dvb_frontend *fe,
+					struct si2157_config *cfg)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = NULL;
+	printk(KERN_INFO "%s: client=%p\n", __func__, client);
+	if(client == NULL)
+		return -1;
+
+	dev = i2c_get_clientdata(client);
+	printk(KERN_INFO "%s: dev=%p\n", __func__, dev);
+	if(dev == NULL)
+		return -1;
+
+	if (cfg) {
+		pr_info("%s(0x%02X): dvb driver submitted configuration; port=%d invert=%d\n",
+				__func__, dev->addr,
+				cfg->if_port, cfg->inversion);
+		dev->inversion = cfg->inversion;
+		dev->if_port   = cfg->if_port;
+	} else {
+		pr_info("%s(0x%02X): default configuration\n",
+				__func__, dev->addr);
+		dev->inversion = true;
+		dev->if_port   = 1;
+	}
 	return 0;
 }
 
 static const struct dvb_tuner_ops si2157_ops = {
 	.info = {
-		.name           = "Silicon Labs Si2141/Si2146/2147/2148/2157/2158",
+		.name           = "Silicon Labs Si2141/2146/2147/2148/2157/2158",
 		.frequency_min  = 42000000,
 		.frequency_max  = 870000000,
 	},
@@ -502,6 +806,10 @@ static const struct dvb_tuner_ops si2157_ops = {
 	.init = si2157_init,
 	.sleep = si2157_sleep,
 	.set_params = si2157_set_params,
+	.set_analog_params = si2157_set_analog_params,
+	.release           = si2157_release,
+	.get_frequency     = si2157_get_frequency,
+	.get_bandwidth     = si2157_get_bandwidth,
 	.get_if_frequency = si2157_get_if_frequency,
 };
 
@@ -524,7 +832,7 @@ static void si2157_stat_work(struct work_struct *work)
 		goto err;
 
 	c->strength.stat[0].scale = FE_SCALE_DECIBEL;
-	c->strength.stat[0].svalue = (s8) cmd.args[3] * 1000;
+	c->strength.stat[0].svalue = ((s8) cmd.args[3]) * 1000;
 
 	schedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));
 	return;
@@ -538,60 +846,22 @@ static int si2157_probe(struct i2c_client *client,
 {
 	struct si2157_config *cfg = client->dev.platform_data;
 	struct dvb_frontend *fe = cfg->fe;
-	struct si2157_dev *dev;
-	struct si2157_cmd cmd;
-	int ret;
+	struct si2157_dev *dev = NULL;
+	unsigned short addr = client->addr;
+	int ret = 0;
+
+	printk(KERN_INFO "%s: probing si2157 tuner fe=%p cfg=%p addr=0X%2x\n",
+			__func__, fe, cfg, addr);
+	fe->tuner_priv = client;
+	si2157_setup_configuration(fe, cfg);
 
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		ret = -ENOMEM;
-		dev_err(&client->dev, "kzalloc() failed\n");
+	if (!dvb_attach(si2157_attach, fe, (u8)addr, client->adapter, cfg)) {
+		printk(KERN_ERR "%s: attaching si2157 tuner failed\n", __func__);
 		goto err;
 	}
 
-	i2c_set_clientdata(client, dev);
-	dev->fe = cfg->fe;
-	dev->inversion = cfg->inversion;
-	dev->if_port = cfg->if_port;
+	dev = i2c_get_clientdata(client);
 	dev->chiptype = (u8)id->driver_data;
-	dev->if_frequency = 5000000; /* default value of property 0x0706 */
-	mutex_init(&dev->i2c_mutex);
-	INIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);
-
-	/* check if the tuner is there */
-	cmd.wlen = 0;
-	cmd.rlen = 1;
-	ret = si2157_cmd_execute(client, &cmd);
-	if (ret)
-		goto err_kfree;
-
-	memcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));
-	fe->tuner_priv = client;
-
-#ifdef CONFIG_MEDIA_CONTROLLER
-	if (cfg->mdev) {
-		dev->mdev = cfg->mdev;
-
-		dev->ent.name = KBUILD_MODNAME;
-		dev->ent.function = MEDIA_ENT_F_TUNER;
-
-		dev->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;
-		dev->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;
-		dev->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;
-
-		ret = media_entity_pads_init(&dev->ent, TUNER_NUM_PADS,
-					     &dev->pad[0]);
-
-		if (ret)
-			goto err_kfree;
-
-		ret = media_device_register_entity(cfg->mdev, &dev->ent);
-		if (ret) {
-			media_entity_cleanup(&dev->ent);
-			goto err_kfree;
-		}
-	}
-#endif
 
 	dev_info(&client->dev, "Silicon Labs %s successfully attached\n",
 			dev->chiptype == SI2157_CHIPTYPE_SI2141 ?  "Si2141" :
@@ -600,8 +870,6 @@ static int si2157_probe(struct i2c_client *client,
 
 	return 0;
 
-err_kfree:
-	kfree(dev);
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
@@ -610,7 +878,12 @@ static int si2157_probe(struct i2c_client *client,
 static int si2157_remove(struct i2c_client *client)
 {
 	struct si2157_dev *dev = i2c_get_clientdata(client);
-	struct dvb_frontend *fe = dev->fe;
+	struct dvb_frontend *fe = NULL;
+	if (dev == NULL) {
+		pr_info("dev is NULL\n");
+		return 0;
+	}
+	fe = dev->fe;
 
 	dev_dbg(&client->dev, "\n");
 
@@ -623,8 +896,7 @@ static int si2157_remove(struct i2c_client *client)
 #endif
 
 	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
-	fe->tuner_priv = NULL;
-	kfree(dev);
+	si2157_release(fe);
 
 	return 0;
 }
@@ -649,7 +921,128 @@ static struct i2c_driver si2157_driver = {
 
 module_i2c_driver(si2157_driver);
 
-MODULE_DESCRIPTION("Silicon Labs Si2141/Si2146/2147/2148/2157/2158 silicon tuner driver");
+struct dvb_frontend *si2157_attach(struct dvb_frontend *fe, u8 addr,
+		struct i2c_adapter *i2c,
+		struct si2157_config *cfg)
+{
+	struct i2c_client *client = NULL;
+	struct si2157_dev *dev = NULL;
+	struct si2157_cmd cmd;
+	int instance = 0, ret;
+
+	pr_info("%s (%d-%04x)\n", __func__,
+	       i2c ? i2c_adapter_id(i2c) : 0,
+	       addr);
+
+	mutex_lock(&si2157_list_mutex);
+
+	if (!cfg) {
+		pr_info("no configuration submitted\n");
+		goto fail;
+	}
+
+	if (!fe) {
+		pr_info("fe is NULL\n");
+		goto fail;
+	}
+
+	client = fe->tuner_priv;
+	if (!client) {
+		pr_info("client is NULL\n");
+		goto fail;
+	}
+
+	instance = hybrid_tuner_request_state(struct si2157_dev, dev,
+			hybrid_tuner_instance_list,
+			i2c, addr, "si2157");
+
+	printk(KERN_INFO "%s: instance=%d\n", __func__, instance);
+	switch (instance) {
+	case 0:
+		goto fail;
+	case 1:
+		/* new tuner instance */
+		pr_info("%s(): new instance for tuner @0x%02x\n", __func__, addr);
+		dev->addr= addr;
+		i2c_set_clientdata(client, dev);
+
+		si2157_setup_configuration(fe, cfg);
+
+		dev->fe = fe;
+		dev->chiptype = (u8)SI2157_CHIPTYPE_SI2157; //BUGBUG - should this come from config?
+		dev->if_frequency = 0;
+
+		mutex_init(&dev->i2c_mutex);
+		INIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);
+
+		break;
+	default:
+		/* existing tuner instance */
+		pr_info("%s(): using existing instance for tuner @0x%02x\n",
+				 __func__, addr);
+
+		/* allow dvb driver to override configuration settings */
+		if(cfg)
+			si2157_setup_configuration(fe, cfg);
+
+		break;
+	}
+
+	/* check if the tuner is there */
+	cmd.wlen = 0;
+	cmd.rlen = 1;
+	ret = si2157_cmd_execute(client, &cmd);
+	/* verify no i2c error and CTS is set */
+	if (ret && (ret != -EAGAIN)) {
+		pr_info("no HW found ret=%d\n", ret);
+		goto fail;
+	}
+
+	memcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));
+
+/* BUGBUG - should this only happen when instance == 1?? */
+#ifdef CONFIG_MEDIA_CONTROLLER
+	if (cfg->mdev) {
+		pr_info("cfg->mdev=%p\n", cfg->mdev);
+		dev->mdev = cfg->mdev;
+
+		dev->ent.name = KBUILD_MODNAME;
+		dev->ent.function = MEDIA_ENT_F_TUNER;
+
+		dev->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;
+		dev->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;
+		dev->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;
+
+		ret = media_entity_pads_init(&dev->ent, TUNER_NUM_PADS,
+					     &dev->pad[0]);
+
+		if (ret)
+			goto fail;
+
+		ret = media_device_register_entity(cfg->mdev, &dev->ent);
+		if (ret) {
+			pr_info("media_device_regiser_entity returns %d\n", ret);
+			media_entity_cleanup(&dev->ent);
+			goto fail;
+		}
+	}
+#endif
+
+	mutex_unlock(&si2157_list_mutex);
+
+	return fe;
+
+fail:
+	printk(KERN_INFO "%s: Failed\n", __func__);
+	mutex_unlock(&si2157_list_mutex);
+
+	if(fe && (instance == 1))
+		si2157_release(fe);
+	return NULL;
+}
+EXPORT_SYMBOL(si2157_attach);
+
+MODULE_DESCRIPTION("Silicon Labs Si2141/2146/2147/2148/2157/2158 silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(SI2158_A20_FIRMWARE);
diff --git a/drivers/media/tuners/si2157.h b/drivers/media/tuners/si2157.h
index 76807f5b3cf8..04b98ef4fdd6 100644
--- a/drivers/media/tuners/si2157.h
+++ b/drivers/media/tuners/si2157.h
@@ -46,4 +46,18 @@ struct si2157_config {
 	u8 if_port;
 };
 
+#if IS_REACHABLE(CONFIG_MEDIA_TUNER_SI2157)
+extern struct dvb_frontend *si2157_attach(struct dvb_frontend *fe, u8 addr,
+					    struct i2c_adapter *i2c,
+					    struct si2157_config *cfg);
+#else
+static inline struct dvb_frontend *si2157_attach(struct dvb_frontend *fe,
+						   u8 addr,
+						   struct i2c_adapter *i2c,
+						   struct si2157_config *cfg)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
 #endif
diff --git a/drivers/media/tuners/si2157_priv.h b/drivers/media/tuners/si2157_priv.h
index e6436f74abaa..6f12b797dde3 100644
--- a/drivers/media/tuners/si2157_priv.h
+++ b/drivers/media/tuners/si2157_priv.h
@@ -19,17 +19,26 @@
 
 #include <linux/firmware.h>
 #include <media/v4l2-mc.h>
+#include <linux/videodev2.h>
+#include "tuner-i2c.h"
 #include "si2157.h"
 
 /* state struct */
 struct si2157_dev {
+	struct list_head hybrid_tuner_instance_list;
+	struct tuner_i2c_props	i2c_props;
+
 	struct mutex i2c_mutex;
+	struct i2c_client *client;
 	struct dvb_frontend *fe;
 	bool active;
 	bool inversion;
 	u8 chiptype;
+	u8 addr;
 	u8 if_port;
 	u32 if_frequency;
+	u32 bandwidth;
+	u32 frequency;
 	struct delayed_work stat_work;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
diff --git a/drivers/media/tuners/tuner-types.c b/drivers/media/tuners/tuner-types.c
index 98bc15a388be..e022ab8d093e 100644
--- a/drivers/media/tuners/tuner-types.c
+++ b/drivers/media/tuners/tuner-types.c
@@ -1433,6 +1433,16 @@ static struct tuner_params tuner_sony_btf_pg463z_params[] = {
 	},
 };
 
+/* ------------ TUNER_SILABS_SI2157 NTSC/PAL/Digital ------------ */
+
+static struct tuner_params tuner_silabs_si2157_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_DIGITAL,
+		.ranges = tuner_fm1236_mk3_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_fm1236_mk3_ntsc_ranges),
+	},
+};
+
 /* --------------------------------------------------------------------- */
 
 struct tunertype tuners[] = {
@@ -1941,6 +1951,11 @@ struct tunertype tuners[] = {
 		.params = tuner_sony_btf_pg463z_params,
 		.count  = ARRAY_SIZE(tuner_sony_btf_pg463z_params),
 	},
+	[TUNER_SILABS_SI2157] = {
+		.name   = "Silicon Labs Si2157 terrestrial/cable multistandard",
+		.params = tuner_silabs_si2157_params,
+		.count  = ARRAY_SIZE(tuner_silabs_si2157_params),
+	},
 };
 EXPORT_SYMBOL(tuners);
 
diff --git a/drivers/media/v4l2-core/tuner-core.c b/drivers/media/v4l2-core/tuner-core.c
index e48b7c032c95..89ef2e106a32 100644
--- a/drivers/media/v4l2-core/tuner-core.c
+++ b/drivers/media/v4l2-core/tuner-core.c
@@ -40,6 +40,7 @@
 #include "xc5000.h"
 #include "tda18271.h"
 #include "xc4000.h"
+#include "si2157.h"
 
 #define UNSET (-1U)
 
@@ -398,6 +399,27 @@ static void set_type(struct i2c_client *c, unsigned int type,
 		tune_now = 0;
 		break;
 	}
+	case TUNER_SILABS_SI2157:
+	{
+		static struct si2157_config silabs_config = {
+		//	.tuner_address           = 0xC0 >> 1,      /* address of the tuner */
+		//	.crystal_trim_xo_cap     = 8,
+		//	.indirect_i2c_connection = 1, /* tuner connected directly(?) */
+			.inversion = true,
+			.if_port   = 1, /*if_port selects the digital IF port, analog assumed to be the other port */
+		};
+
+		printk(KERN_INFO "%s: looking for si2157 tuner on i2c bus: %d\n",
+		       __func__, i2c_adapter_id(t->i2c->adapter));
+
+		if (!dvb_attach(si2157_attach, &t->fe, t->i2c->addr, t->i2c->adapter, &silabs_config)) {
+			printk(KERN_ERR "%s: attaching si2157 tuner failed\n", __func__);
+			goto attach_failed;
+		}
+		printk(KERN_INFO "%s: si2157 tuner attached\n", __func__);
+		tune_now = 0;
+		break;
+	}
 	default:
 		if (!dvb_attach(simple_tuner_attach, &t->fe,
 				t->i2c->adapter, t->i2c->addr, t->type))
diff --git a/include/media/tuner.h b/include/media/tuner.h
index b3edc14e763f..cab980a0c5d2 100644
--- a/include/media/tuner.h
+++ b/include/media/tuner.h
@@ -142,6 +142,8 @@
 #define TUNER_SONY_BTF_PK467Z		90	/* NTSC_JP */
 #define TUNER_SONY_BTF_PB463Z		91	/* NTSC */
 
+#define TUNER_SILABS_SI2157		92  /* Silicon Labs terrestrial/cable tuner series */
+
 /* tv card specific */
 #define TDA9887_PRESENT			(1<<0)
 #define TDA9887_PORT1_INACTIVE		(1<<1)
-- 
2.11.0

