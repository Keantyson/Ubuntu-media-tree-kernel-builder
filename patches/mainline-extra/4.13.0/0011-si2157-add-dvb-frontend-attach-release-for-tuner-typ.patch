From 637f68a469fb84f42001dda08cae2a32165637e5 Mon Sep 17 00:00:00 2001
From: Brad Love <hidden@email.co>
Date: Wed, 29 Nov 2017 17:44:56 +0000
Subject: [PATCH 11/25] si2157: add dvb frontend attach/release for tuner type

 Adds tuner type TUNER_SILABS_SI2157 to tuner core. Includes dvb attach/release
 functions with hybrid_tuner_instance_list for mutliple frontend support.

 Renamed si2157_attach function in saa7164 driver to fix compilation error
 caused by introduction of si2157_attach in the si2157 driver.
---
 drivers/media/pci/saa7164/saa7164-dvb.c |  11 +-
 drivers/media/tuners/si2157.c           | 256 +++++++++++++++++++++++++-------
 drivers/media/tuners/si2157.h           |  14 ++
 drivers/media/tuners/si2157_priv.h      |   5 +
 drivers/media/tuners/tuner-types.c      |  15 ++
 drivers/media/v4l2-core/tuner-core.c    |  21 +++
 include/media/tuner.h                   |   2 +
 7 files changed, 265 insertions(+), 59 deletions(-)

diff --git a/drivers/media/pci/saa7164/saa7164-dvb.c b/drivers/media/pci/saa7164/saa7164-dvb.c
index e76d3bafe2ce..9522c6c80566 100644
--- a/drivers/media/pci/saa7164/saa7164-dvb.c
+++ b/drivers/media/pci/saa7164/saa7164-dvb.c
@@ -110,8 +110,9 @@ static struct si2157_config hauppauge_hvr2255_tuner_config = {
 	.if_port = 1,
 };
 
-static int si2157_attach(struct saa7164_port *port, struct i2c_adapter *adapter,
-	struct dvb_frontend *fe, u8 addr8bit, struct si2157_config *cfg)
+static int si2157_attach_priv(struct saa7164_port *port,
+	struct i2c_adapter *adapter, struct dvb_frontend *fe,
+	u8 addr8bit, struct si2157_config *cfg)
 {
 	struct i2c_board_info bi;
 	struct i2c_client *tuner;
@@ -624,11 +625,13 @@ int saa7164_dvb_register(struct saa7164_port *port)
 		if (port->dvb.frontend != NULL) {
 
 			if (port->nr == 0) {
-				si2157_attach(port, &dev->i2c_bus[0].i2c_adap,
+				si2157_attach_priv(port,
+					      &dev->i2c_bus[0].i2c_adap,
 					      port->dvb.frontend, 0xc0,
 					      &hauppauge_hvr2255_tuner_config);
 			} else {
-				si2157_attach(port, &dev->i2c_bus[1].i2c_adap,
+				si2157_attach_priv(port,
+					      &dev->i2c_bus[1].i2c_adap,
 					      port->dvb.frontend, 0xc0,
 					      &hauppauge_hvr2255_tuner_config);
 			}
diff --git a/drivers/media/tuners/si2157.c b/drivers/media/tuners/si2157.c
index f8e9469d406a..8fc3bb075033 100644
--- a/drivers/media/tuners/si2157.c
+++ b/drivers/media/tuners/si2157.c
@@ -18,6 +18,11 @@
 
 static const struct dvb_tuner_ops si2157_ops;
 
+static DEFINE_MUTEX(si2157_list_mutex);
+static LIST_HEAD(hybrid_tuner_instance_list);
+
+/*---------------------------------------------------------------------*/
+
 /* execute firmware command */
 static int si2157_cmd_execute(struct i2c_client *client, struct si2157_cmd *cmd)
 {
@@ -495,6 +500,58 @@ static int si2157_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
 	return 0;
 }
 
+static void si2157_release(struct dvb_frontend *fe)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = NULL;
+
+	pr_info("%s: client=%p\n", __func__, client);
+	if (client == NULL)
+		return;
+
+	dev = i2c_get_clientdata(client);
+	pr_info("%s: dev=%p\n", __func__, dev);
+	if (dev == NULL)
+		return;
+
+	mutex_lock(&si2157_list_mutex);
+	hybrid_tuner_release_state(dev);
+	mutex_unlock(&si2157_list_mutex);
+
+	i2c_set_clientdata(client, NULL);
+	fe->tuner_priv = NULL;
+}
+
+static int si2157_setup_configuration(struct dvb_frontend *fe,
+					struct si2157_config *cfg)
+{
+	struct i2c_client *client = fe->tuner_priv;
+	struct si2157_dev *dev = NULL;
+
+	pr_info("%s: client=%p\n", __func__, client);
+	if (client == NULL)
+		return -1;
+
+	dev = i2c_get_clientdata(client);
+	pr_info("%s: dev=%p\n", __func__, dev);
+	if (dev == NULL)
+		return -1;
+
+	if (cfg) {
+		pr_info("%s(0x%02X): dvb driver submitted configuration; port=%d invert=%d\n",
+				__func__, dev->addr,
+				cfg->if_port, cfg->inversion);
+		dev->inversion = cfg->inversion;
+		dev->if_port   = cfg->if_port;
+	} else {
+		pr_info("%s(0x%02X): default configuration\n",
+				__func__, dev->addr);
+		dev->inversion = true;
+		dev->if_port   = 1;
+	}
+	return 0;
+}
+
 static const struct dvb_tuner_ops si2157_ops = {
 	.info = {
 		.name           = "Silicon Labs Si2141/Si2146/2147/2148/2157/2158",
@@ -505,6 +562,7 @@ static const struct dvb_tuner_ops si2157_ops = {
 	.init = si2157_init,
 	.sleep = si2157_sleep,
 	.set_params = si2157_set_params,
+	.release           = si2157_release,
 	.get_if_frequency = si2157_get_if_frequency,
 };
 
@@ -541,60 +599,23 @@ static int si2157_probe(struct i2c_client *client,
 {
 	struct si2157_config *cfg = client->dev.platform_data;
 	struct dvb_frontend *fe = cfg->fe;
-	struct si2157_dev *dev;
-	struct si2157_cmd cmd;
-	int ret;
+	struct si2157_dev *dev = NULL;
+	unsigned short addr = client->addr;
+	int ret = 0;
+
+	pr_info("%s: probing si2157 tuner fe=%p cfg=%p addr=0X%2x\n",
+			__func__, fe, cfg, addr);
+	fe->tuner_priv = client;
+	si2157_setup_configuration(fe, cfg);
 
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		ret = -ENOMEM;
-		dev_err(&client->dev, "kzalloc() failed\n");
+	if (!dvb_attach(si2157_attach, fe, (u8)addr, client->adapter, cfg)) {
+		dev_err(&client->dev, "%s: attaching si2157 tuner failed\n",
+				__func__);
 		goto err;
 	}
 
-	i2c_set_clientdata(client, dev);
-	dev->fe = cfg->fe;
-	dev->inversion = cfg->inversion;
-	dev->if_port = cfg->if_port;
+	dev = i2c_get_clientdata(client);
 	dev->chiptype = (u8)id->driver_data;
-	dev->if_frequency = 5000000; /* default value of property 0x0706 */
-	mutex_init(&dev->i2c_mutex);
-	INIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);
-
-	/* check if the tuner is there */
-	cmd.wlen = 0;
-	cmd.rlen = 1;
-	ret = si2157_cmd_execute(client, &cmd);
-	if (ret)
-		goto err_kfree;
-
-	memcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));
-	fe->tuner_priv = client;
-
-#ifdef CONFIG_MEDIA_CONTROLLER
-	if (cfg->mdev) {
-		dev->mdev = cfg->mdev;
-
-		dev->ent.name = KBUILD_MODNAME;
-		dev->ent.function = MEDIA_ENT_F_TUNER;
-
-		dev->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;
-		dev->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;
-		dev->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;
-
-		ret = media_entity_pads_init(&dev->ent, TUNER_NUM_PADS,
-					     &dev->pad[0]);
-
-		if (ret)
-			goto err_kfree;
-
-		ret = media_device_register_entity(cfg->mdev, &dev->ent);
-		if (ret) {
-			media_entity_cleanup(&dev->ent);
-			goto err_kfree;
-		}
-	}
-#endif
 
 	dev_info(&client->dev, "Silicon Labs %s successfully attached\n",
 			dev->chiptype == SI2157_CHIPTYPE_SI2141 ?  "Si2141" :
@@ -603,8 +624,6 @@ static int si2157_probe(struct i2c_client *client,
 
 	return 0;
 
-err_kfree:
-	kfree(dev);
 err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
@@ -613,7 +632,13 @@ static int si2157_probe(struct i2c_client *client,
 static int si2157_remove(struct i2c_client *client)
 {
 	struct si2157_dev *dev = i2c_get_clientdata(client);
-	struct dvb_frontend *fe = dev->fe;
+	struct dvb_frontend *fe = NULL;
+
+	if (dev == NULL) {
+		pr_info("dev is NULL\n");
+		return 0;
+	}
+	fe = dev->fe;
 
 	dev_dbg(&client->dev, "\n");
 
@@ -626,8 +651,7 @@ static int si2157_remove(struct i2c_client *client)
 #endif
 
 	memset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));
-	fe->tuner_priv = NULL;
-	kfree(dev);
+	si2157_release(fe);
 
 	return 0;
 }
@@ -652,7 +676,129 @@ static struct i2c_driver si2157_driver = {
 
 module_i2c_driver(si2157_driver);
 
-MODULE_DESCRIPTION("Silicon Labs Si2141/Si2146/2147/2148/2157/2158 silicon tuner driver");
+struct dvb_frontend *si2157_attach(struct dvb_frontend *fe, u8 addr,
+		struct i2c_adapter *i2c,
+		struct si2157_config *cfg)
+{
+	struct i2c_client *client = NULL;
+	struct si2157_dev *dev = NULL;
+	struct si2157_cmd cmd;
+	int instance = 0, ret;
+
+	pr_info("%s (%d-%04x)\n", __func__,
+	       i2c ? i2c_adapter_id(i2c) : 0,
+	       addr);
+
+	mutex_lock(&si2157_list_mutex);
+
+	if (!cfg) {
+		pr_info("no configuration submitted\n");
+		goto fail;
+	}
+
+	if (!fe) {
+		pr_info("fe is NULL\n");
+		goto fail;
+	}
+
+	client = fe->tuner_priv;
+	if (!client) {
+		pr_info("client is NULL\n");
+		goto fail;
+	}
+
+	instance = hybrid_tuner_request_state(struct si2157_dev, dev,
+			hybrid_tuner_instance_list,
+			i2c, addr, "si2157");
+
+	pr_info("%s: instance=%d\n", __func__, instance);
+	switch (instance) {
+	case 0:
+		goto fail;
+	case 1:
+		/* new tuner instance */
+		pr_info("%s(): new instance for tuner @0x%02x\n",
+				__func__, addr);
+		dev->addr = addr;
+		i2c_set_clientdata(client, dev);
+
+		si2157_setup_configuration(fe, cfg);
+
+		dev->fe = fe;
+		/* BUGBUG - should chiptype come from config? */
+		dev->chiptype = (u8)SI2157_CHIPTYPE_SI2157;
+		dev->if_frequency = 0;
+
+		mutex_init(&dev->i2c_mutex);
+		INIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);
+
+		break;
+	default:
+		/* existing tuner instance */
+		pr_info("%s(): using existing instance for tuner @0x%02x\n",
+				 __func__, addr);
+
+		/* allow dvb driver to override configuration settings */
+		if (cfg)
+			si2157_setup_configuration(fe, cfg);
+
+		break;
+	}
+
+	/* check if the tuner is there */
+	cmd.wlen = 0;
+	cmd.rlen = 1;
+	ret = si2157_cmd_execute(client, &cmd);
+	/* verify no i2c error and CTS is set */
+	if (ret && (ret != -EAGAIN)) {
+		pr_info("no HW found ret=%d\n", ret);
+		goto fail;
+	}
+
+	memcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));
+
+#ifdef CONFIG_MEDIA_CONTROLLER
+	if (instance == 1 && cfg->mdev) {
+		pr_info("cfg->mdev=%p\n", cfg->mdev);
+		dev->mdev = cfg->mdev;
+
+		dev->ent.name = KBUILD_MODNAME;
+		dev->ent.function = MEDIA_ENT_F_TUNER;
+
+		dev->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;
+		dev->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;
+		dev->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;
+
+		ret = media_entity_pads_init(&dev->ent, TUNER_NUM_PADS,
+					     &dev->pad[0]);
+
+		if (ret)
+			goto fail;
+
+		ret = media_device_register_entity(cfg->mdev, &dev->ent);
+		if (ret) {
+			pr_info("media_device_regiser_entity returns %d\n", ret);
+			media_entity_cleanup(&dev->ent);
+			goto fail;
+		}
+	}
+#endif
+
+	mutex_unlock(&si2157_list_mutex);
+
+	return fe;
+
+fail:
+	pr_info("%s: Failed\n", __func__);
+	mutex_unlock(&si2157_list_mutex);
+
+	if (fe && (instance == 1))
+		si2157_release(fe);
+	return NULL;
+}
+EXPORT_SYMBOL(si2157_attach);
+
+MODULE_DESCRIPTION("Silicon Labs Si2141/2146/2147/2148/2157/2158 silicon tuner driver");
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(SI2158_A20_FIRMWARE);
diff --git a/drivers/media/tuners/si2157.h b/drivers/media/tuners/si2157.h
index 76807f5b3cf8..fd008cc4cd82 100644
--- a/drivers/media/tuners/si2157.h
+++ b/drivers/media/tuners/si2157.h
@@ -46,4 +46,18 @@ struct si2157_config {
 	u8 if_port;
 };
 
+#if IS_REACHABLE(CONFIG_MEDIA_TUNER_SI2157)
+extern struct dvb_frontend *si2157_attach(struct dvb_frontend *fe, u8 addr,
+					    struct i2c_adapter *i2c,
+					    struct si2157_config *cfg);
+#else
+static inline struct dvb_frontend *si2157_attach(struct dvb_frontend *fe,
+						   u8 addr,
+						   struct i2c_adapter *i2c,
+						   struct si2157_config *cfg)
+{
+	pr_err("%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
 #endif
diff --git a/drivers/media/tuners/si2157_priv.h b/drivers/media/tuners/si2157_priv.h
index e6436f74abaa..2801aaa5ffe2 100644
--- a/drivers/media/tuners/si2157_priv.h
+++ b/drivers/media/tuners/si2157_priv.h
@@ -19,15 +19,20 @@
 
 #include <linux/firmware.h>
 #include <media/v4l2-mc.h>
+#include "tuner-i2c.h"
 #include "si2157.h"
 
 /* state struct */
 struct si2157_dev {
+	struct list_head hybrid_tuner_instance_list;
+	struct tuner_i2c_props  i2c_props;
+
 	struct mutex i2c_mutex;
 	struct dvb_frontend *fe;
 	bool active;
 	bool inversion;
 	u8 chiptype;
+	u8 addr;
 	u8 if_port;
 	u32 if_frequency;
 	struct delayed_work stat_work;
diff --git a/drivers/media/tuners/tuner-types.c b/drivers/media/tuners/tuner-types.c
index 98bc15a388be..e022ab8d093e 100644
--- a/drivers/media/tuners/tuner-types.c
+++ b/drivers/media/tuners/tuner-types.c
@@ -1433,6 +1433,16 @@ static struct tuner_params tuner_sony_btf_pg463z_params[] = {
 	},
 };
 
+/* ------------ TUNER_SILABS_SI2157 NTSC/PAL/Digital ------------ */
+
+static struct tuner_params tuner_silabs_si2157_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_DIGITAL,
+		.ranges = tuner_fm1236_mk3_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_fm1236_mk3_ntsc_ranges),
+	},
+};
+
 /* --------------------------------------------------------------------- */
 
 struct tunertype tuners[] = {
@@ -1941,6 +1951,11 @@ struct tunertype tuners[] = {
 		.params = tuner_sony_btf_pg463z_params,
 		.count  = ARRAY_SIZE(tuner_sony_btf_pg463z_params),
 	},
+	[TUNER_SILABS_SI2157] = {
+		.name   = "Silicon Labs Si2157 terrestrial/cable multistandard",
+		.params = tuner_silabs_si2157_params,
+		.count  = ARRAY_SIZE(tuner_silabs_si2157_params),
+	},
 };
 EXPORT_SYMBOL(tuners);
 
diff --git a/drivers/media/v4l2-core/tuner-core.c b/drivers/media/v4l2-core/tuner-core.c
index 8db45dfc271b..6bd4cad9a817 100644
--- a/drivers/media/v4l2-core/tuner-core.c
+++ b/drivers/media/v4l2-core/tuner-core.c
@@ -40,6 +40,7 @@
 #include "xc5000.h"
 #include "tda18271.h"
 #include "xc4000.h"
+#include "si2157.h"
 
 #define UNSET (-1U)
 
@@ -396,6 +397,26 @@ static void set_type(struct i2c_client *c, unsigned int type,
 		tune_now = 0;
 		break;
 	}
+	case TUNER_SILABS_SI2157:
+	{
+		static struct si2157_config silabs_config = {
+			.inversion = true,
+			.if_port   = 1, /* selects the digital IF port */
+					/* analog assumed to be other port */
+		};
+
+		dprintk("%s: looking for si2157 tuner on i2c bus: %d\n",
+		       __func__, i2c_adapter_id(t->i2c->adapter));
+
+		if (!dvb_attach(si2157_attach, &t->fe, t->i2c->addr,
+				t->i2c->adapter, &silabs_config)) {
+			dprintk("%s: attaching si2157 tuner failed\n", __func__);
+			goto attach_failed;
+		}
+		dprintk("%s: si2157 tuner attached\n", __func__);
+		tune_now = 0;
+		break;
+	}
 	default:
 		if (!dvb_attach(simple_tuner_attach, &t->fe,
 				t->i2c->adapter, t->i2c->addr, t->type))
diff --git a/include/media/tuner.h b/include/media/tuner.h
index b3edc14e763f..cab980a0c5d2 100644
--- a/include/media/tuner.h
+++ b/include/media/tuner.h
@@ -142,6 +142,8 @@
 #define TUNER_SONY_BTF_PK467Z		90	/* NTSC_JP */
 #define TUNER_SONY_BTF_PB463Z		91	/* NTSC */
 
+#define TUNER_SILABS_SI2157		92  /* Silicon Labs terrestrial/cable tuner series */
+
 /* tv card specific */
 #define TDA9887_PRESENT			(1<<0)
 #define TDA9887_PORT1_INACTIVE		(1<<1)
-- 
2.14.1

